"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[30573],{12799:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>n,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var s=r(74848),o=r(28453);const i={sidebar_position:1,title:"SRTheo"},c="SRSE Product: SRTheo",a={id:"MessageSchemas/Schema/SRSE Products/SRTheo/SRTheo",title:"SRTheo",description:"| # | Message Name | Description |",source:"@site/versioned_docs/version-8.4.10.2/MessageSchemas/Schema/SRSE Products/SRTheo/SRTheo.md",sourceDirName:"MessageSchemas/Schema/SRSE Products/SRTheo",slug:"/MessageSchemas/Schema/SRSE Products/SRTheo/",permalink:"/docs/8.4.10.2/MessageSchemas/Schema/SRSE Products/SRTheo/",draft:!1,unlisted:!1,tags:[],version:"8.4.10.2",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"SRTheo"},sidebar:"messageSchemasSidebar",previous:{title:"SpreadPrint",permalink:"/docs/8.4.10.2/MessageSchemas/Schema/SRSE Products/SRSpread/SpreadPrint/"},next:{title:"OptionTheoVol",permalink:"/docs/8.4.10.2/MessageSchemas/Schema/SRSE Products/SRTheo/OptionTheoVol/"}},n={},d=[];function h(e){const t={a:"a",h1:"h1",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"srse-product-srtheo",children:"SRSE Product: SRTheo"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"#"}),(0,s.jsx)(t.th,{children:"Message Name"}),(0,s.jsx)(t.th,{children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"5055"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"./OptionTheoVol",children:"OptionTheoVol"})}),(0,s.jsx)(t.td,{children:"OptionTheoVol records contain client supplied theoretical volatility surface information resolved at the level if individual strikes.  Strike volatilities, prices, greeks and SpiderRock surface volatilites and prices are all available.  Values are computed on the fly using fast/accurate calculation methods as records are returned."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1950"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"./SROptTheoRecord",children:"SROptTheoRecord"})}),(0,s.jsx)(t.td,{children:"SpdrOptTheoRecords can be used to override theoretical volatilities for specific strikes when using SpdrTheoExpSurface records."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1955"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"./SRTheoExp2PtCurve",children:"SRTheoExp2PtCurve"})}),(0,s.jsx)(t.td,{children:"SpdrTheoExp2PtCurve records are used along side SpdrTheoExpSurface records to provide a complete x/y specification of a theoretical skew curve. Spline interpolation is used for values between x/y points"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1960"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"./SRTheoExpSurface",children:"SRTheoExpSurface"})}),(0,s.jsx)(t.td,{children:"SpdrTheoExpSurface records reprent a client theoretical volatility surface for a ExpiryKey (ticker + expiration).  These records can either directly specify parameters to be used in a parameterized surface function or can link to a record (eg. SpdrTheoExp2PtCurve) containing x/y points sampling a client constructed curve.  Alternatively, they can specify that a SpiderRock implied skew curve should be used along with client supplied atm volatilities."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1105"}),(0,s.jsx)(t.td,{children:(0,s.jsx)(t.a,{href:"./TheoSurfacePerf",children:"TheoSurfacePerf"})}),(0,s.jsx)(t.td,{children:"TheoSurfacePerf records are published throughout he day for each active client theoretical model in the SpiderRock system.  They are suitable for tracking performance of a theoretical model surface whether or not it is being traded."})]})]})]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>c,x:()=>a});var s=r(96540);const o={},i=s.createContext(o);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);