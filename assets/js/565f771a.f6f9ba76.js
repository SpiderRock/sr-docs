"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([["88152"],{638685(e,i,n){n.r(i),n.d(i,{metadata:()=>t,default:()=>h,frontMatter:()=>o,contentTitle:()=>a,toc:()=>d,assets:()=>c});var t=JSON.parse('{"id":"Documentation/V8Migration/QuantV7toV8","title":"Quant Differences","description":"Pricing Options on Cash Indexes","source":"@site/docs/Documentation/V8Migration/QuantV7toV8.md","sourceDirName":"Documentation/V8Migration","slug":"/Documentation/V8Migration/QuantV7toV8","permalink":"/docs/next/Documentation/V8Migration/QuantV7toV8","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Quant Differences","sidebar_position":3},"sidebar":"documentationSidebar","previous":{"title":"Risk Differences","permalink":"/docs/next/Documentation/V8Migration/RiskV7toV8"},"next":{"title":"Corporate Action Differences","permalink":"/docs/next/Documentation/V8Migration/CorpActionsV7toV8"}}'),r=n(886070),s=n(848193);let o={title:"Quant Differences",sidebar_position:3},a,c={},d=[{value:"Pricing Options on Cash Indexes",id:"pricing-options-on-cash-indexes",level:2},{value:"Estimating Spot from Forwards: <em>synSpot</em>",id:"estimating-spot-from-forwards-synspot",level:3},{value:"Volatility Time Changes",id:"volatility-time-changes",level:2},{value:"Binary Days",id:"binary-days",level:2},{value:"Theta",id:"theta",level:2}];function l(e){let i={a:"a",em:"em",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.h2,{id:"pricing-options-on-cash-indexes",children:"Pricing Options on Cash Indexes"}),"\n",(0,r.jsx)(i.p,{children:"In the Version 7 (V7) SpiderRock Platform, options on cash indexes were priced using the generalized Black-Scholes framework. In Version 8 (V8), we are now pricing these using the Black-76 approach in an option-on-forward framework where the forward price is used as the underlying."}),"\n",(0,r.jsxs)(i.p,{children:["The live forward price is computed from a driver market which is typically a more liquid and highly correlated instrument. The relationship between the driver market and implied forward price is calibrated over a short rolling window (usually ~60 seconds) and is referred to as ",(0,r.jsx)(i.em,{children:"uPrcRatio"}),". In V7, this relationship was captured in offset variable ",(0,r.jsx)(i.em,{children:"uPrcOffset"}),". The driver market used is reported in the surface curve records."]}),"\n",(0,r.jsxs)(i.h3,{id:"estimating-spot-from-forwards-synspot",children:["Estimating Spot from Forwards: ",(0,r.jsx)(i.em,{children:"synSpot"})]}),"\n",(0,r.jsxs)(i.p,{children:["When pricing with a forward price in V8, we provide a synthetic spot price in the ",(0,r.jsx)(i.em,{children:"synSpot"})," column for clients who require a spot price estimate. The synthetic spot price is derived via log-linear regression on the term structure of ",(0,r.jsx)(i.em,{children:"uPrc"})," values within the surface curve records."]}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["The median ",(0,r.jsx)("i",{children:"synSpot"})," value over the first six months of the curve tends to be reasonably well-correlated with the actual spot index price."]}),(0,r.jsx)("li",{children:"This approach offers a practical estimate of spot even in forward-based frameworks where direct spot pricing modeling is not used."})]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.em,{children:"synSpot"})," has been added to the following messages:"]}),"\n",(0,r.jsxs)("ul",{children:[(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://docs.spiderrockconnect.com/docs/next/MessageSchemas/Schema/Topics/analytics/LiveSurfaceCurve/",children:(0,r.jsx)("b",{children:(0,r.jsx)("i",{children:"liveSurfaceCurve"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://docs.spiderrockconnect.com/docs/next/MessageSchemas/Schema/Topics/analytics/LiveAtmVol/",children:(0,r.jsx)("b",{children:(0,r.jsx)("i",{children:"liveAtmVol"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://docs.spiderrockconnect.com/docs/next/MessageSchemas/Schema/Topics/analytics/LiveImpliedQuote/",children:(0,r.jsx)("b",{children:(0,r.jsx)("i",{children:"liveImpliedQuote"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"https://docs.spiderrockconnect.com/docs/next/MessageSchemas/Schema/Topics/analytics/LiveImpliedQuoteAdj/",children:(0,r.jsx)("b",{children:(0,r.jsx)("i",{children:"liveImpliedQuoteAdj"})})})})]}),"\n",(0,r.jsx)(i.h2,{id:"volatility-time-changes",children:"Volatility Time Changes"}),"\n",(0,r.jsx)(i.p,{children:"In V7, equity trading hours are defined as 8:30 AM to 3:00 PM Central Time (CT), resulting in a 6.5-hour trading session. Time outside this window is treated as non-trading."}),"\n",(0,r.jsx)(i.p,{children:"In V8, the equity trading window has been extended to 8:30 AM to 4:00 PM Central Time (CT), aligning with the full regular market session and resulting in a 7.5-hour trading day."}),"\n",(0,r.jsx)(i.p,{children:"Additionally, the expiration time for PM expiries was moved from 3:30 PM CT in V7 to 4 PM CT in V8."}),"\n",(0,r.jsxs)(i.p,{children:["Read more on our ",(0,r.jsx)(i.a,{href:"/docs/next/Documentation/PlatformFeatures/Analytics/VolTimeCalc",children:(0,r.jsx)(i.strong,{children:"Volatility Time Calculations"})})," page."]}),"\n",(0,r.jsx)(i.h2,{id:"binary-days",children:"Binary Days"}),"\n",(0,r.jsx)(i.p,{children:"In V7, the trading day used for calculating binary days was 8:30 AM to 3:00 PM CT. In V8, it's from 8:30 to 4:00 PM CT."}),"\n",(0,r.jsx)(i.h2,{id:"theta",children:"Theta"}),"\n",(0,r.jsx)(i.p,{children:"The discrete calculation for theta in V7 did not change the underlying price. In V8, the calculation adjusts for the expected drift in the model during the change in time. As a result, V8 theta is more symmetric between calls and puts."})]})}function h(e={}){let{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},848193(e,i,n){n.d(i,{R:()=>o,x:()=>a});var t=n(830758);let r={},s=t.createContext(r);function o(e){let i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);