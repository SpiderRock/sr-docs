"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([["36197"],{827874(e,n,t){t.r(n),t.d(n,{metadata:()=>r,default:()=>p,frontMatter:()=>a,contentTitle:()=>o,toc:()=>c,assets:()=>d});var r=JSON.parse('{"id":"Documentation/PlatformAPIs/MLink/Examples","title":"Common MLink Queries","description":"| Example                                                 | Description                                                                          |","source":"@site/versioned_docs/version-8.5.12.1/Documentation/PlatformAPIs/MLink/8.Examples.md","sourceDirName":"Documentation/PlatformAPIs/MLink","slug":"/Documentation/PlatformAPIs/MLink/Examples","permalink":"/docs/8.5.12.1/Documentation/PlatformAPIs/MLink/Examples","draft":false,"unlisted":false,"tags":[],"version":"8.5.12.1","sidebarPosition":8,"frontMatter":{"title":"Common MLink Queries","sidebar_position":8},"sidebar":"documentationSidebar","previous":{"title":"LiveImpliedQuote to LiveImpliedQuoteAdj Conversion","permalink":"/docs/8.5.12.1/Documentation/PlatformAPIs/MLink/MessageConversion"},"next":{"title":"FIX","permalink":"/docs/8.5.12.1/Documentation/PlatformAPIs/FIX/"}}'),s=t(886070),i=t(848193);let a={title:"Common MLink Queries",sidebar_position:8},o,d={},c=[{value:"AAPL Firehose",id:"aapl-firehose",level:2},{value:"MLinkStream Surfaces",id:"mlinkstream-surfaces",level:2},{value:"Child Orders",id:"child-orders",level:2},{value:"MLinkStream Symbol Risk",id:"mlinkstream-symbol-risk",level:2},{value:"Parent Limit Order",id:"parent-limit-order",level:2},{value:"Step One: Send order to parentOrder table.",id:"step-one-send-order-to-parentorder-table",level:3},{value:"Step Two: Add order to parentLimit table for further updates.",id:"step-two-add-order-to-parentlimit-table-for-further-updates",level:3},{value:"Step Three: Update order params.",id:"step-three-update-order-params",level:3}];function m(e){let n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#aapl-firehose",children:(0,s.jsx)(n.strong,{children:"AAPL Firehose"})})}),(0,s.jsx)(n.td,{children:"Streams the NBBO as filtered for AAPL only."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#mlinkstream-surfaces",children:(0,s.jsx)(n.strong,{children:"MLinkStream Surfaces"})})}),(0,s.jsx)(n.td,{children:"Streams surface information from LiveImpliedQuoteAdjust to display best bid and ask."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#child-orders",children:(0,s.jsx)(n.strong,{children:"Child Orders"})})}),(0,s.jsx)(n.td,{children:"Displays working child orders (if any exist.)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#mlinkstream-symbol-risk",children:(0,s.jsx)(n.strong,{children:"MLinkStream Symbol Risk"})})}),(0,s.jsx)(n.td,{children:"Streams risk information on symbols in their account (if any exist)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#parent-limit-order",children:(0,s.jsx)(n.strong,{children:"Parent Limit Order"})})}),(0,s.jsx)(n.td,{children:"Details a three stage process to send orders with an AUX limit."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"aapl-firehose",children:"AAPL Firehose"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport json\nimport time\n\nimport websockets\nimport nest_asyncio\nimport threading\nimport datetime\nfrom IPython.display import display\nimport pandas as pd\nfrom pandas import json_normalize\nnest_asyncio.apply()\n\nuriJson = "wss://mlink-live.nms.venus.spiderrockconnect.com/mlink/json"\nauthentication_key = ""\n\nstream_df = pd.DataFrame(columns=["ticker", "bidPrice1", "askPrice1"])  # Global DataFrame for accumulating messages\n\nasync def recv_msg(websocket):\n    global stream_df\n\n    buffer = await websocket.recv()\n    result = json.loads(buffer)\n\n    if isinstance(result, dict):\n        if result.get("header", {}).get("mTyp") == "StockBookQuote":\n            msg = result.get("message", {})\n            pkey = msg.get("pkey", {}).get("ticker", {})\n            ticker = f"{pkey.get(\'tk\')}-{pkey.get(\'ts\')}-{pkey.get(\'at\')}"\n            record = {\n                "ticker": ticker,\n                "bidPrice1": msg.get("bidPrice1"),\n                "askPrice1": msg.get("askPrice1")\n            }\n\n            # Only append if all values are present\n            if all(record.values()):\n                stream_df = pd.concat([stream_df, pd.DataFrame([record])], ignore_index=True)\n                #print(stream_df.tail(1))  # Show latest\n                display(stream_df.tail(1))\n\n    return True\n\nasync def query_mlink(authentication_key):\n    retry = True\n    while retry:\n        try:\n            async with websockets.connect(uriJson,\n                                          additional_headers={"Authorization": f"Bearer {authentication_key}"},\n                                          ping_timeout=None) as websocket:\n                msg = {\n                    "header": {\n                        "mTyp": "MLinkStream"\n                    },\n                    "message": {\n                        "queryLabel": "ExampleStockNbbo",\n                        "activeLatency": 1, #you can stream AAPL with minimum latency\n                        "msgName": "StockBookQuote", #the message you wish to stream\n                        "view":"ticker|bidprice1|askprice1",\n                        "where":"ticker:eq:AAPL-NMS-EQT" #can also do ticker.tk:eq:AAPL & ticker.at:eq:EQT & ticker.ts:eq:NMS\n                    }\n                }\n                t = time.time_ns()\n                tstr = \'.\'.join([time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1000000000)), "%06d" % ((t / 1000) % 1000000)])\n                msg[\'header\'][\'sTim\'] = tstr\n                msg[\'header\'][\'encT\'] = tstr\n                smsg = json.dumps(msg)\n                await websocket.send(smsg)\n                notDone = True\n                while notDone:\n                    notDone = await recv_msg(websocket)\n\n        except asyncio.exceptions.TimeoutError:\n            print("timeout occurred, retrying...")\n\n\nif __name__ == "__main__":\n    asyncio.run(query_mlink(authentication_key))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"mlinkstream-surfaces",children:"MLinkStream Surfaces"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport json\nimport time\nimport websockets\nimport nest_asyncio\nimport pandas as pd\nfrom pandas import json_normalize\nfrom IPython.display import display\n\nnest_asyncio.apply()\n\nuriJson = "wss://mlink-live.nms.venus.spiderrockconnect.com/mlink/json"\nauthentication_key = ""\n\nasync def recv_msg(websocket):\n    buffer = await websocket.recv()\n    result = json.loads(buffer)\n    print(result)\n    return True\n\nstream_df = pd.DataFrame(columns=["ticker","Call/Put" ,"strike","opt_exp","delta" ,"uprc", "obid", "oask","obiv","oaiv","svol","timestamp"])\n\nasync def recv_msg(websocket):\n    global stream_df\n\n    buffer = await websocket.recv()\n    result = json.loads(buffer)\n\n    if isinstance(result, dict):\n        if result.get("header", {}).get("mTyp") == "LiveImpliedQuoteAdj":\n            msg = result.get("message", {})\n\n            # Build ticker from message.ticker\n            #t = msg.get("ticker", {})\n            #ticker = f"{t.get(\'tk\')}-{t.get(\'ts\')}-{t.get(\'at\')}"\n            ticker = msg.get("pkey", {}).get("okey", {}).get("tk")\n\n            # Extract strike from pkey.okey.xx\n            strike = msg.get("pkey", {}).get("okey", {}).get("xx")\n\n            # Extract Call/Put from pkey.okey.xx\n            callput = msg.get("pkey", {}).get("okey", {}).get("cp")\n\n            # Extract opt_exp from pkey.okey.xx\n            opt_exp = msg.get("pkey", {}).get("okey", {}).get("dt")\n\n            record = {\n                "ticker": ticker,\n                "strike": strike,\n                "Call/Put": callput,\n                "opt_exp": opt_exp,\n                "uprc": msg.get("uprc"),\n                "obid": msg.get("obid"),\n                "oask": msg.get("oask"),\n                "obiv": msg.get("obiv"),\n                "oaiv": msg.get("oaiv"),\n                "svol": msg.get("svol"),\n                "delta": msg.get("de"),\n                "timestamp": msg.get("timestamp")\n            }\n\n            #if all(record.values()):\n            #stream_df = pd.concat([stream_df, pd.DataFrame([record])], ignore_index=True)\n            #print(stream_df.tail(5))\n            display(pd.DataFrame([record]))\n\n    return True\n\nasync def send_signal(websocket):\n    while True:\n        await asyncio.sleep(20)\n        signal = {\n            "header": {\n                "mTyp": "MLinkSignalReady"\n            },\n            "message": {\n               # "sesionID": "",\n               # "signalID": "",\n                "readyScan": "FullScan"\n            }\n        }\n        t = time.time_ns()\n        tstr = \'.\'.join([\n            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n            "%06d" % ((t / 1_000) % 1_000_000)\n        ])\n        signal[\'header\'][\'sTim\'] = tstr\n        signal[\'header\'][\'encT\'] = tstr\n        smsg = json.dumps(signal)\n        await websocket.send(smsg)\n        await asyncio.sleep(0)\n\nasync def query_mlink(authentication_key):\n    retry = True\n    while retry:\n        try:\n            async with websockets.connect(\n                uriJson,\n                additional_headers={"Authorization": f"Bearer {authentication_key}"},\n                ping_timeout=None\n            ) as websocket:\n\n                msg = {\n                    "header": {\n                        "mTyp": "MLinkStream"\n                    },\n                    "message": {\n                        "queryLabel": "ExampleStockNbbo",\n                        "activeLatency": 5000,\n                        "msgName": "LiveImpliedQuoteAdj",\n                        #"view":"ticker|xx|uprc|obid|oask|svol|de|ga|th|ve",\n                        #"where": "ticker:eq:SPY-NMS-EQT-2025-05-16%26de:cb:0.40$0.60%26de:cb:-0.40$-0.60"\n                        #"where": "okey:eq:SPY-NMS-EQT-2025-05-16 &  ((de:ge:-0.60 & de:le:-0.40) | (de:ge:0.40 & de:le:0.60))"\n                        #line above does the same thing as this line below\n                        #"where": "okey:eq:SPY-NMS-EQT-2025-05-21 &  ((de:cb:-0.60$-0.40) | (de:cb:0.40$0.60))"\n                        "where": "ticker:eq:SPY-NMS-EQT & ((de:cb:-0.60$-0.40) | (de:cb:0.40$0.60)) & years:lt:.006"\n                    }\n                }\n\n                t = time.time_ns()\n                tstr = \'.\'.join([\n                    time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n                    "%06d" % ((t / 1_000) % 1_000_000)\n                ])\n                msg[\'header\'][\'sTim\'] = tstr\n                msg[\'header\'][\'encT\'] = tstr\n\n                await websocket.send(json.dumps(msg))\n                asyncio.create_task(send_signal(websocket))\n\n                notDone = True\n                while notDone:\n                    notDone = await recv_msg(websocket)\n\n        except asyncio.exceptions.TimeoutError:\n            print("Timeout occurred, retrying...")\n\nif __name__ == "__main__":\n    asyncio.run(query_mlink(authentication_key))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"child-orders",children:"Child Orders"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport json\nimport time\nimport websockets\nimport nest_asyncio\nimport pandas as pd\nfrom IPython.display import display\n\nnest_asyncio.apply()\n\nuriJson = "wss://mlink-live.nms.venus.spiderrockconnect.com/mlink/json"\nauthentication_key = ""\n\n# Initialize DataFrame\n#account,username ,ticker, dt, xx, cp, orderside,limitPrice, nbbobid, nbboask, ordersize, leavesQuantity\nstream_df = pd.DataFrame(columns=["accnt","userName","ticker","exp","strike","call/put","orderSide","child_px","child_sz","child_ex"])\n\nasync def recv_msg(websocket):\n    global stream_df\n\n    buffer = await websocket.recv()\n    result = json.loads(buffer)\n\n    if isinstance(result, dict):\n        if result.get("header", {}).get("mTyp") == "SpdrParentBrkrState":\n            msg = result.get("message", {})\n\n            account = msg.get("pkey", {}).get("accnt")\n            user_name = msg.get("userName")\n            ticker = msg.get("pkey", {}).get("secKey", {}).get("tk")\n            exp_date = msg.get("pkey", {}).get("secKey", {}).get("dt")\n            strike = msg.get("pkey", {}).get("secKey", {}).get("xx")\n            call_put = msg.get("pkey", {}).get("secKey", {}).get("cp")\n            order_side = msg.get("pkey", {}).get("orderSide")\n            child_price = msg.get("cpx1")\n            child_size = msg.get("csz1")\n            child_ex = msg.get("cex1")\n            #orderSize = msg.get("orderSize")\n            #leavesQuantity = msg.get("leavesQuantity")\n\n\n            record = {\n                "accnt": account,\n                "userName": user_name,\n                "ticker": ticker,\n                "exp": exp_date,\n                "strike": strike,\n                "call/put": call_put,\n                "orderSide": order_side,\n                "child_px": child_price,\n                "child_sz": child_size,\n                "child_ex": child_ex\n                #"ordersize": orderSize,\n                #"leavesQuantity": leavesQuantity\n\n            }\n\n            #if all(record.values()):\n            #    stream_df = pd.concat([stream_df, pd.DataFrame([record])], ignore_index=True)\n            #    print(stream_df.tail(5))\n            show_df = pd.DataFrame([record])\n            #print(pd.DataFrame([record]))\n            display(show_df)\n    return True\n\nasync def send_signal(websocket):\n    while True:\n        await asyncio.sleep(20)\n        signal = {\n            "header": {\n                "mTyp": "MLinkSignalReady"\n            },\n            "message": {\n                "readyScan": "FullScan"\n            }\n        }\n        t = time.time_ns()\n        tstr = \'.\'.join([\n            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n            "%06d" % ((t / 1_000) % 1_000_000)\n        ])\n        signal[\'header\'][\'sTim\'] = tstr\n        signal[\'header\'][\'encT\'] = tstr\n        await websocket.send(json.dumps(signal))\n        await asyncio.sleep(0)\n\nasync def query_mlink(authentication_key):\n    retry = True\n    while retry:\n        try:\n            async with websockets.connect(\n                uriJson,\n                additional_headers={"Authorization": f"Bearer {authentication_key}"},\n                ping_timeout=None\n            ) as websocket:\n\n                msg = {\n                    "header": {\n                        "mTyp": "MLinkStream"\n                    },\n                    "message": {\n                        "queryLabel": "ExampleSymbolRiskSummary",\n                        "activeLatency": 900,\n                        "msgName": "SpdrParentBrkrState",\n                        #"view": "userName|cpx1|cex1|csz1",\n                        "where": "accnt:eq:T.MTL.VEN & spdrBrokerStatus:eq:ACTIVE"\n                    }\n                }\n\n                t = time.time_ns()\n                tstr = \'.\'.join([\n                    time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n                    "%06d" % ((t / 1_000) % 1_000_000)\n                ])\n                msg[\'header\'][\'sTim\'] = tstr\n                msg[\'header\'][\'encT\'] = tstr\n\n                await websocket.send(json.dumps(msg))\n                asyncio.create_task(send_signal(websocket))\n\n                while True:\n                    await recv_msg(websocket)\n\n        except asyncio.exceptions.TimeoutError:\n            print("Timeout occurred, retrying...")\n\nif __name__ == "__main__":\n    asyncio.run(query_mlink(authentication_key))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"mlinkstream-symbol-risk",children:"MLinkStream Symbol Risk"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport json\nimport time\nimport websockets\nimport nest_asyncio\nimport pandas as pd\nfrom IPython.display import display\n\nnest_asyncio.apply()\n\nuriJson = "wss://mlink-live.nms.venus.spiderrockconnect.com/mlink/json"\nauthentication_key = ""\n\n# Initialize DataFrame\nstream_df = pd.DataFrame(columns=["ticker", "tradeDate", "VaRsu50", "VaRsd50"])\n\nasync def recv_msg(websocket):\n    global stream_df\n\n    buffer = await websocket.recv()\n    result = json.loads(buffer)\n\n    if isinstance(result, dict):\n        if result.get("header", {}).get("mTyp") == "SymbolRiskSummaryV5":\n            msg = result.get("message", {})\n\n            #ticker = msg.get("ticker")\n            ticker = msg.get("pkey", {}).get("ticker", {}).get("tk")\n            #trade_date = msg.get("tradeDate")\n            trade_date = msg.get("pkey", {}).get("tradeDate")\n            var_su50 = msg.get("VaRsu50")\n            var_sd50 = msg.get("VaRsd50")\n\n            record = {\n                "ticker": ticker,\n                "tradeDate": trade_date,\n                "VaRsu50": var_su50,\n                "VaRsd50": var_sd50\n            }\n\n            #if all(record.values()):\n            #    stream_df = pd.concat([stream_df, pd.DataFrame([record])], ignore_index=True)\n            #    print(stream_df.tail(5))\n            #print(pd.DataFrame([record]))\n            display(pd.DataFrame([record]))\n    return True\n\nasync def send_signal(websocket):\n    while True:\n        await asyncio.sleep(20)\n        signal = {\n            "header": {\n                "mTyp": "MLinkSignalReady"\n            },\n            "message": {\n                "readyScan": "FullScan"\n            }\n        }\n        t = time.time_ns()\n        tstr = \'.\'.join([\n            time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n            "%06d" % ((t / 1_000) % 1_000_000)\n        ])\n        signal[\'header\'][\'sTim\'] = tstr\n        signal[\'header\'][\'encT\'] = tstr\n        await websocket.send(json.dumps(signal))\n        await asyncio.sleep(0)\n\nasync def query_mlink(authentication_key):\n    retry = True\n    while retry:\n        try:\n            async with websockets.connect(\n                uriJson,\n                additional_headers={"Authorization": f"Bearer {authentication_key}"},\n                ping_timeout=None\n            ) as websocket:\n\n                msg = {\n                    "header": {\n                        "mTyp": "MLinkStream"\n                    },\n                    "message": {\n                        "queryLabel": "ExampleSymbolRiskSummary",\n                        "activeLatency": 2500,\n                        "msgName": "SymbolRiskSummaryV5",\n                        #"view": "ticker|accnt|tradeDate|VaRsu50|VaRsd50",\n                        #"where": "ticker:eq:AAPL-NMS-EQT & risksession:eq:regular & tradeDate:eq:2025-05-20"\n                        "where": "accnt:eq:T.TJ.VEN3 & tradeDate:eq:2025-06-05"\n                    }\n                }\n\n                t = time.time_ns()\n                tstr = \'.\'.join([\n                    time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(t / 1_000_000_000)),\n                    "%06d" % ((t / 1_000) % 1_000_000)\n                ])\n                msg[\'header\'][\'sTim\'] = tstr\n                msg[\'header\'][\'encT\'] = tstr\n\n                await websocket.send(json.dumps(msg))\n                asyncio.create_task(send_signal(websocket))\n\n                while True:\n                    await recv_msg(websocket)\n\n        except asyncio.exceptions.TimeoutError:\n            print("Timeout occurred, retrying...")\n\nif __name__ == "__main__":\n    asyncio.run(query_mlink(authentication_key))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"parent-limit-order",children:"Parent Limit Order"}),"\n",(0,s.jsx)(n.h3,{id:"step-one-send-order-to-parentorder-table",children:"Step One: Send order to parentOrder table."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Initially, this will do nothing as limitType is equal to AUX."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import requests\nimport json\nimport time\nimport copy\n\n# REST endpoint and auth token\nrest_url = "https://mlink-live.nms.venus.spiderrockconnect.com/rest/json"\nauthentication_key = ""\n\n# Base order payload template\nbase_order_payload = {\n    "header": {\n        "mTyp": "SpdrParentOrder"\n    },\n    "message": {\n        "secKey": {\n            "at": "EQT",\n            "ts": "NMS",\n            "tk": "AAPL",\n            "dt": "2025-07-18",\n            "xx": 200,\n            "cp": "Put"\n            },\n        "positionType": "Auto",\n        "parentShape": "Single",\n        "secType": "Option",\n        "accnt": "T.MTL.VEN", # <-- insert your account here\n        "orderSide": "Sell",\n        "clientFirm": "SRCORE",\n        "spdrActionType": "Add",\n        "startType": 0,\n        "orderSize": 50,\n        "orderActiveSize": 7,\n        "marketSession": "RegMkt",\n        "parentOrderHandling": "PostOnly",\n        "parentBalanceHandling": "PostLimit",\n        "orderLimitType": "Aux",\n        "takeLimitClass": "SurfProb",\n        "makeLimitClass": "SurfProb",\n        "takeProbability": 0.1,\n        "makeProbability": 0.3,\n        "takeAlphaType": "Static",\n        "makeAlphaType": "Static",\n        "takeReachRule": "None",\n        "publicSize": "FullSizeR",\n        "numMakeExchanges": 1,\n        "autohedge": "None",\n        "userName": "matt.leli",\n        "maxGrpDayDDeltaLn": 100000.0,\n        "maxGrpDayDDeltaSh": 100000.0,\n        "maxGrpDayVegaLn": 100000.0,\n        "maxGrpDayVegaSh": 100000.0,\n        "orderDuration": -1,\n        "maxExposureSize": -1,\n        "spdrStageType": "None",\n        "progressExposeTime": 0,\n        "userData1": "Default",\n        "userData2": "EXAMPLE_STRATEGY",\n        "orderVolLimit": 0.24\n    }\n}\n\ndef generate_distinct_ids():\n    """Generate 10 distinct grouping codes and risk group IDs"""\n    grouping_codes = []\n    risk_group_ids = []\n\n    for i in range(10):\n        # Generate distinct grouping codes (incrementing the last segment)\n        grouping_code = f"2137-1312-3867-{5309 + i}"\n        grouping_codes.append(grouping_code)\n\n        # Generate distinct risk group IDs (incrementing the last segment)\n        risk_group_id = f"4124-3534-5867-{5309 + i}"\n        risk_group_ids.append(risk_group_id)\n\n    return grouping_codes, risk_group_ids\n\ndef create_order_payload(grouping_code, risk_group_id):\n    """Create an order payload with specific grouping code and risk group ID"""\n    order_payload = base_order_payload.copy()\n    order_payload["message"] = base_order_payload["message"].copy()\n    order_payload["message"]["groupingCode"] = grouping_code\n    order_payload["message"]["riskGroupId"] = risk_group_id\n    return order_payload\n\ndef submit_order(order_payload, order_number):\n    """Submit a single order"""\n    try:\n        headers = {\n            "Authorization": f"Bearer {authentication_key}",\n            "Content-Type": "application/json"\n        }\n\n        # Use postmsgs command with required parameters only\n        params = {\n            "cmd": "postmsgs",\n            "postaction": "I"  # (I)nsert - required parameter\n        }\n\n        response = requests.post(rest_url, headers=headers, params=params, json=[order_payload])\n        response.raise_for_status()\n        print(f"Order {order_number} - Gateway response:", response.json())\n        return True\n\n    except requests.RequestException as e:\n        print(f"Order {order_number} - Submission failed:", e)\n        if hasattr(e, \'response\') and e.response is not None:\n            print(f"Order {order_number} - Response status:", e.response.status_code)\n            print(f"Order {order_number} - Response text:", e.response.text)\n        return False\n\ndef submit_multiple_orders():\n    """Submit 10 orders with distinct grouping codes and risk group IDs"""\n    grouping_codes, risk_group_ids = generate_distinct_ids()\n\n    successful_orders = 0\n    failed_orders = 0\n    orders_in_current_second = 0\n    second_start_time = time.time()\n\n    for i in range(10):\n        # Rate limiting: max 4 orders per second\n        current_time = time.time()\n        time_elapsed = current_time - second_start_time\n\n        if time_elapsed >= 3.0:\n            # Reset counter for new second\n            orders_in_current_second = 0\n            second_start_time = current_time\n        elif orders_in_current_second >= 2:\n            # Wait for next second if we\'ve hit the limit\n            sleep_time = 1.0 - time_elapsed\n            print(f"Rate limit reached, waiting {sleep_time:.2f} seconds...")\n            time.sleep(sleep_time)\n            orders_in_current_second = 0\n            second_start_time = time.time()\n\n        print(f"\\nSubmitting order {i + 1}/10...")\n        print(f"Grouping Code: {grouping_codes[i]}")\n        print(f"Risk Group ID: {risk_group_ids[i]}")\n\n        order_payload = create_order_payload(grouping_codes[i], risk_group_ids[i])\n\n        if submit_order(order_payload, i + 1):\n            successful_orders += 1\n        else:\n            failed_orders += 1\n\n        orders_in_current_second += 1\n\n    print(f"\\n=== Summary ===")\n    print(f"Successful orders: {successful_orders}")\n    print(f"Failed orders: {failed_orders}")\n\nif __name__ == "__main__":\n    submit_multiple_orders()\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-two-add-order-to-parentlimit-table-for-further-updates",children:"Step Two: Add order to parentLimit table for further updates."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"*Note:"})," When first sending to spdrParentLimit, the orderLimitType and orderActiveSize is changed.*"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Base order payload for Replace\nbase_order_payload = {\n    "header": {\n        "mTyp": "SpdrParentLimit"\n    },\n    "message": {\n        "secKey": {\n            "at": "EQT",\n            "ts": "NMS",\n            "tk": "AAPL",\n            "dt": "2025-07-18",\n            "xx": 200,\n            "cp": "Put"\n        },\n        "positionType": "Auto",\n        "parentShape": "Single",\n        "secType": "Option",\n        "accnt": "T.MTL.VEN",\n        "orderSide": "Sell",\n        "groupingCode": "placeholder",  # will be replaced\n        "clientFirm": "SRCORE",\n        "spdrActionType": "Replace",\n        "orderLimitType": "Vol",\n        "takeLimitClass": "SurfProb",\n        "makeLimitClass": "SurfProb",\n        "orderActiveSize": 27,\n        "orderVolLimit": 0.275,\n        "takeAlphaType": "Static",\n        "makeAlphaType": "Static",\n        "takeProbability": 0.1,\n        "makeProbability": 0.3,\n        "takeSurfVolOffset": 0.1,\n        "makeSurfVolOffset": 0.1,\n        "maxGrpDayDDeltaLn": 100000.0,\n        "maxGrpDayDDeltaSh": 100000.0,\n        "maxGrpDayVegaLn": 100000.0,\n        "maxGrpDayVegaSh": 100000.0,\n        "addCumFillQuantity": "No",\n        "spdrSource": "MLink"\n    }\n}\n\ndef get_matching_grouping_codes():\n    """Return groupingCodes used in the original insert orders"""\n    return [f"2137-1312-3867-{5309 + i}" for i in range(10)]\n\ndef create_order_payload(grouping_code):\n    """Create a payload with updated grouping code"""\n    payload = copy.deepcopy(base_order_payload)\n    payload["message"]["groupingCode"] = grouping_code\n    return payload\n\ndef submit_order(payload, order_number):\n    """Submit a single replace order"""\n    try:\n        headers = {\n            "Authorization": f"Bearer {authentication_key}",\n            "Content-Type": "application/json"\n        }\n\n        params = {\n            "cmd": "postmsgs",\n            "postaction": "I"  # Insert action still used for Replace\n        }\n\n        response = requests.post(rest_url, headers=headers, params=params, json=[payload])\n        response.raise_for_status()\n        print(f"Order {order_number} - Gateway response:", response.json())\n        return True\n\n    except requests.RequestException as e:\n        print(f"Order {order_number} - Submission failed:", e)\n        if hasattr(e, \'response\') and e.response is not None:\n            print("Response status:", e.response.status_code)\n            print("Response text:", e.response.text)\n        return False\n\ndef submit_replacement_orders():\n    """Submit 10 SpdrParentLimit Replace orders"""\n    grouping_codes = get_matching_grouping_codes()\n    success_count = 0\n    failure_count = 0\n\n    for i, code in enumerate(grouping_codes, start=1):\n        print(f"\\nSubmitting replacement order {i} with groupingCode: {code}")\n        payload = create_order_payload(code)\n        if submit_order(payload, i):\n            success_count += 1\n        else:\n            failure_count += 1\n\n    print("\\n=== Summary ===")\n    print(f"Successful replacements: {success_count}")\n    print(f"Failed replacements: {failure_count}")\n\nif __name__ == "__main__":\n    submit_replacement_orders()\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-three-update-order-params",children:"Step Three: Update order params."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Base order payload for Replace\nbase_order_payload = {\n    "header": {\n        "mTyp": "SpdrParentLimit"\n    },\n    "message": {\n        "secKey": {\n            "at": "EQT",\n            "ts": "NMS",\n            "tk": "AAPL",\n            "dt": "2025-07-18",\n            "xx": 200,\n            "cp": "Put"\n        },\n        "positionType": "Auto",\n        "parentShape": "Single",\n        "secType": "Option",\n        "accnt": "T.MTL.VEN",\n        "orderSide": "Sell",\n        "groupingCode": "placeholder",  # will be replaced\n        "clientFirm": "SRCORE",\n        "spdrActionType": "Replace",\n        "orderLimitType": "Vol",\n        "takeLimitClass": "SurfProb",\n        "makeLimitClass": "SurfProb",\n        "orderActiveSize": 44,\n        "orderVolLimit": 0.25,\n        "takeAlphaType": "Static",\n        "makeAlphaType": "Static",\n        "takeProbability": 0.1,\n        "makeProbability": 0.3,\n        "takeSurfVolOffset": 0.1,\n        "makeSurfVolOffset": 0.1,\n        "maxGrpDayDDeltaLn": 100000.0,\n        "maxGrpDayDDeltaSh": 100000.0,\n        "maxGrpDayVegaLn": 100000.0,\n        "maxGrpDayVegaSh": 100000.0,\n        "addCumFillQuantity": "No",\n        "spdrSource": "MLink"\n    }\n}\n\ndef get_matching_grouping_codes():\n    """Return groupingCodes used in the original insert orders"""\n    return [f"2137-1312-3867-{5309 + i}" for i in range(10)]\n\ndef create_order_payload(grouping_code):\n    """Create a payload with updated grouping code"""\n    payload = copy.deepcopy(base_order_payload)\n    payload["message"]["groupingCode"] = grouping_code\n    return payload\n\ndef submit_order(payload, order_number):\n    """Submit a single replace order"""\n    try:\n        headers = {\n            "Authorization": f"Bearer {authentication_key}",\n            "Content-Type": "application/json"\n        }\n\n        params = {\n            "cmd": "postmsgs",\n            "postaction": "U"  # Insert action still used for Replace\n        }\n\n        response = requests.post(rest_url, headers=headers, params=params, json=[payload])\n        response.raise_for_status()\n        print(f"Order {order_number} - Gateway response:", response.json())\n        return True\n\n    except requests.RequestException as e:\n        print(f"Order {order_number} - Submission failed:", e)\n        if hasattr(e, \'response\') and e.response is not None:\n            print("Response status:", e.response.status_code)\n            print("Response text:", e.response.text)\n        return False\n\ndef submit_replacement_orders():\n    """Submit 10 SpdrParentLimit Replace orders"""\n    grouping_codes = get_matching_grouping_codes()\n    success_count = 0\n    failure_count = 0\n\n    for i, code in enumerate(grouping_codes, start=1):\n        print(f"\\nSubmitting replacement order {i} with groupingCode: {code}")\n        payload = create_order_payload(code)\n        if submit_order(payload, i):\n            success_count += 1\n        else:\n            failure_count += 1\n\n    print("\\n=== Summary ===")\n    print(f"Successful replacements: {success_count}")\n    print(f"Failed replacements: {failure_count}")\n\nif __name__ == "__main__":\n    submit_replacement_orders()\n'})})]})}function p(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},848193(e,n,t){t.d(n,{R:()=>a,x:()=>o});var r=t(830758);let s={},i=r.createContext(s);function a(e){let n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);